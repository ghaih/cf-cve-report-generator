package downloader

import (
	"github.com/google/go-github/github"
	"fmt"
	"context"
	"regexp"
	"os"
	"net/http"
	"io"
	"archive/zip"
	"path/filepath"
	"strings"
	"log"
	"golang.org/x/oauth2"
)

type CVE struct {
	Release string
	CveId string
}


func DownloadReleases(ctx context.Context, owner string, repo string, until string) []CVE{
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: "51fe18499d2e35123e4a0d0327e77624e4b1ee89"},
	)
	tc := oauth2.NewClient(ctx, ts)

	client := github.NewClient(tc)

	//client := github.NewClient(client)
	cves := regexp.MustCompile(`CVE-\d+-\d+`)

	result := []CVE{}

	for pageNum :=0; pageNum < 100; pageNum++ {
		opt := &github.ListOptions{Page: pageNum, PerPage: 100}
		releases, _, err := client.Repositories.ListReleases(ctx, owner, repo, opt)

		if err == nil {
			for _, release := range releases {

				for _, cve := range cves.FindAllString(*release.Body, 999) {
					if len(cve) == 0 {
						break
					}

					result = append(result, CVE{Release:*release.TagName, CveId:cve})
				}

				if strings.EqualFold(*release.TagName, until){
					return result
				}
			}

		} else {
			fmt.Println(err)
		}
	}

	return result
}

func DownloadCVEDATA(year string){
	fileName := fmt.Sprintf("%s%s%s", "nvdcve-1.0-" , year , ".json")

	out, _ := os.Create(fileName + ".zip")
	defer out.Close()
	resp, err := http.Get("https://static.nvd.nist.gov/feeds/json/cve/1.0/" + fileName +".zip")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()
	_, err = io.Copy(out, resp.Body)

	if err != nil {
		fmt.Println(err)
		return
	}

	_, err = Unzip(fileName + ".zip", "output")
}

func Unzip(src, dest string) ([]string, error) {

	var filenames []string

	r, err := zip.OpenReader(src)
	if err != nil {
		return filenames, err
	}
	defer r.Close()

	for _, f := range r.File {

		rc, err := f.Open()
		if err != nil {
			return filenames, err
		}
		defer rc.Close()

		// Store filename/path for returning and using later on
		fpath := filepath.Join(dest, f.Name)
		filenames = append(filenames, fpath)

		if f.FileInfo().IsDir() {

			// Make Folder
			os.MkdirAll(fpath, os.ModePerm)

		} else {

			// Make File
			var fdir string
			if lastIndex := strings.LastIndex(fpath, string(os.PathSeparator)); lastIndex > -1 {
				fdir = fpath[:lastIndex]
			}

			err = os.MkdirAll(fdir, os.ModePerm)
			if err != nil {
				log.Fatal(err)
				return filenames, err
			}
			f, err := os.OpenFile(
				fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
			if err != nil {
				return filenames, err
			}
			defer f.Close()

			_, err = io.Copy(f, rc)
			if err != nil {
				return filenames, err
			}

		}
	}
	return filenames, nil
}
